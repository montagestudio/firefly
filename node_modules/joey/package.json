{
  "name": "joey",
  "version": "1.5.3",
  "description": "A Sinatra-like web server configuration language for JavaScript, built on Q, Q-IO, and JSGI.",
  "license": "BSD-3-Clause",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/montagejs/joey.git"
  },
  "main": "joey.js",
  "dependencies": {
    "optimist": "~0.3.7",
    "q": "^1.5.0",
    "q-io": "^1.13.4",
    "url2": "~1.0.0"
  },
  "bin": {
    "joey": "bin/joey"
  },
  "scripts": {
    "test": "node test/all.js"
  },
  "devDependencies": {
    "test": "0.6.x"
  },
  "readme": "\n[![Build Status](https://travis-ci.org/montagejs/joey.png?branch=master)](http://travis-ci.org/montagejs/joey)\n\nJoey\n====\n\nA [Sinatra][]-like and [jQuery][]-like web server (and client!)\nconfiguration language in JavaScript for [NodeJS][] and [NPM][], based\non [JSGI][], [Q][], and [Q-IO][].\n\n[Joey Bishop][JB] was a member of the [Humphrey][HB] [Bogart][Bogart]'s\n[Rat Pack][RP], which included [Frank][FS] [Sinatra][Sinatra],\n[Dean][DM] [Martin][], [Peter Lawford][PL], and [Sammy][Sammy] [Davis\nJr.][SDJ].\n\n[Sinatra]: http://www.sinatrarb.com/\n[jQuery]: http://jquery.com/\n[NodeJS]: http://nodejs.org/\n[NPM]: http://npmjs.org/\n[JSGI]: http://wiki.commonjs.org/wiki/JSGI\n[Q]: https://github.com/kriskowal/q\n[Q-IO]: https://github.com/kriskowal/q-io\n[Sammy]: http://sammyjs.org/\n[Bogart]: https://github.com/nrstott/bogart\n[Martin]: https://github.com/thegrubbsian/Martin\n[RP]: http://en.wikipedia.org/wiki/Rat_Pack\n[JB]: http://en.wikipedia.org/wiki/Joey_Bishop\n[HB]: http://en.wikipedia.org/wiki/Humphrey_Bogart\n[PL]: http://en.wikipedia.org/wiki/Peter_Lawford\n[SDJ]: http://en.wikipedia.org/wiki/Sammy_Davis,_Jr.\n[DM]: http://en.wikipedia.org/wiki/Dean_Martin\n[FS]: http://en.wikipedia.org/wiki/Frank_Sinatra\n\n\nInstallation\n============\n\nYou will need [NodeJS][] and [NPM][].\n\n    $ npm install joey\n\nOr add it to your package:\n\n    {\n        \"dependencies\": {\n            \"joey\": \"*\"\n        }\n    }\n\nAnd install your package.\n\n    $ npm install\n\nTo run tests, you'll need a developer install.\n\n    $ npm install -d\n    $ node test/all.js\n\n\nHello, You!\n===========\n\n```javascript\nrequire(\"joey\")\n.log()\n.error()\n.favicon()\n.route(function ($) {\n\n    $(\"\")\n    .method(\"GET\")\n    .contentType(\"text/plain\")\n    .content(\"Hello, World!\")\n\n    $(\"hello/:name\")\n    .method(\"GET\")\n    .contentType(\"text/html\")\n    .contentApp(function (request) {\n        return \"Hello, \" + request.params.name + \"!\\n\";\n    })\n\n    $(\"store\")\n    .methods(function ($) {\n\n        var content = \"\\n\";\n\n        $(\"GET\")\n        .contentType(\"text/plain\")\n        .contentApp(function () {\n            return content;\n        });\n\n        $(\"PUT\")\n        .tap(function (request) {\n            return request.body.read()\n            .then(function (_content) {\n                content = _content.toString(\"utf-8\");\n            });\n        })\n        .redirect(\"\");\n\n    })\n\n    $(\"files/...\").fileTree(\".\"); // danger!\n\n})\n.listen(8080)\n.then(function () {\n    console.log(\"Listening on 8080\")\n\n    // client\n    var request = require(\"joey\").redirectTrap(20).client();\n\n    request(\"http://localhost:8080\")\n    .then(function (response) {\n        console.log(response.status, response.headers);\n        response.body.read()\n        .invoke('toString', 'utf-8')\n        .then(console.log)\n    })\n})\n.done()\n```\n\nUsage\n=====\n\nRoutes start with Joey.\n\n```javascript\nrequire(\"joey\")\n```\n\nBranches end with an application, like some static content.\n\n```javascript\n.content(\"Hello, World!\")\n```\n\nOr some dynamic content.\n\n```javascript\n.contentApp(function (request) {\n    return \"Hello, \" + request.pathInfo + \"\\n\";\n})\n```\n\nOr a file, with its content type intuitied from the extension.\n\n```javascript\n.file(module.path || __filename)\n```\n\nOr a file with a specific content type, or status code.\n\n```javascript\n.file(module.path || __filename, \"text/plain\", 200)\n```\n\nOr some content in a directory tree.\n\n```javascript\n.fileTree(module.directory || __dirname)\n```\n\nOr proxy another server.\n\n```javascript\n.proxyTree(\"http://example.com/\")\n```\n\nOr a temporary or permanent redirect.\n\n```javascript\n.redirect(\"../foo\")\n.redirectPermanent(\"../bar\")\n```\n\nRedirect paths are implicitly resolved relative to the request URL.\nWith no argument, a redirect implicitly loops back to the same path,\nwhich is handy for redirecting to a ``GET`` after a ``PUT`` or ``POST``.\n\nOr you can respond with an HTTP error.\n\n```javascript\n.badRequest()\n.notFound()\n.methodNotAllowed()\n.notAcceptable()\n```\n\nOr JSGI applications.  If you're using promises, the response can be a\npromise. The body can be a promise. The body may be anything with a\n``forEach(write)`` method.  ``forEach(write)`` may return a promise,\nwhich upon resolution will end the response.  ``write(content)`` may\nreturn a promise, particularly for throttling.\n\n```javascript\n.app(function (request) {\n    return {\n        status: 200,\n        headers: {\n            \"content-type\": \"text/plain\"\n        },\n        \"body\": [\n            \"Hello, \" + request.pathInfo + \"\\n\"\n        ]\n    }\n})\n```\n\nOr Node-style applications.\n\n```javascript\n.nap(function (request, response) {\n    response.writeHead(200, {\n        \"content-type\": \"text/plain\",\n        \"charset\": \"utf-8\"\n    });\n    request.on(\"data\", function (data) {\n        response.write(data);\n    });\n    request.on(\"end\", function () {\n        response.end();\n    })\n})\n```\n\nIf you want to observe a request as it trickles down the chain, but do\nnot want to respond to it yourself, you can use a tap.\n\n```javascript\n.tap(function (request, response) {\n    assert.equal(request.method, \"PUT\", \"method is PUT\");\n})\n.redirect(\"/\")\n```\n\nYou can use a trap to intercept a response.\n\n```javascript\n.trap(function (response) {\n    response.headers[\"set-cookie\"] = \"id=1; HttpOnly\";\n})\n```\n\nThere is also a ``cap`` method in the ``app``, ``nap``, ``tap``,\n``trap`` theme, at the end of routing.  ``cap`` limits subsequent\nresponders to the portion of the URL that has already been routed; all\nother requests are \"not found\".\n\n```javascript\n.cap()\n.content(\"Hello, World\");\n```\n\n\nListening\n---------\n\nWhich you can then serve as a web application.\n\n```javascript\n.listen(8080)\n.then(function (server) {\n    console.log(\"Listening on 8080\");\n})\n.done()\n```\n\n\nRouting\n-------\n\nAnd you can create branches.\n\n```javascript\n.route(function ($) {\n    $(\"\").content('<a href=\"/hello\">Hello</a>', 'text/html');\n    $(\"hello\").content(\"Hello, World!\");\n})\n```\n\nAnd the branches can be nested.\n\n```javascript\n.route(function ($) {\n    $(\"hello\").content(\"Hi!\");\n    $(\"hello/...\").route(function ($) {\n        $(\"world\").content(\"Hello, World!\");\n        $(\"joey\").content(\"Hello, Joey!\");\n        $(\"dave\").content(\"Hello, Dave!\");\n    });\n})\n```\n\nThe arguments to the ``$`` function (as named in these examples; you may\nof course name it anything you like) are conditions for matching a\nbranch.  If a branch does not match the remaining routes are searched in\norder.\n\nThe path expression can contain variables.\n\n```javascript\n.route(function ($) {\n    $(\"hello/:name\").contentApp(function (request) {\n        return \"Hello, \" + request.params.name + \"!\";\n    });\n})\n```\n\nVariables start with either ``:``, ``*``, or ``...``, have an optional\nname, and may be followed by ``?``.  If there's a slash before a\nvariable, it receives special treatment when the variable is optional.\n\n-   ``:name`` is a named variable, matching zero or more non-slash\n    characters.  The matching characters are stored in\n    ``request.params.name``.\n-   ``*name`` is a named variable, matching all following characters\n    including slashes.\n-   ``:`` and ``*`` without a following letter character are anonymous\n    variables.  They are accessible by their zero-index offset among the\n    other parameters, like ``request.params[0]``.\n-   ``/:name?`` is an optional variable. It, and even the slash that\n    comes before it, can be omitted and the expression will still match.\n    -   ``/:?`` optional variables can also be anonymous\n    -   ``/*name?`` and match all following text including slashes\n    -   ``:name?`` do not need to follow a slash\n    -   or any combination thereof\n-   ``/...`` matches the slash and everything that follows.  The entire\n    match, including the slash, becomes the path for subsequent routing,\n    stored in ``request.pathInfo``.\n\nThe path expressions have a default prefix of a slash, ``/``.  An\nalternate prefix can be provided, for example, if you wish to match file\nextension.\n\n```javascript\n.route(function ($) {\n    $(\"foo\").route(\".\", function ($) {\n\n        // \"/foo.html\"\n        $(\"html\")\n        .contentType(\"text/html\")\n        .content(\"<p>Hello, World</p>\")\n\n        // \"/foo.txt\"\n        $(\"txt\")\n        .contentType(\"text/plain\")\n        .content(\"Hello, World\")\n\n    })\n})\n```\n\nYou can limit a path to a particular HTTP method.  Any HTTP method may\nbe used, in addition to the special ``ANY`` method.\n\n```javascript\n.route(function (ANY, GET) {\n    GET(\"hello\").content(\"Hello, World!\");\n})\n```\n\nThe common methods are provided as positional arguments, of which you\ncan take as many as you need: ``ANY``, ``GET``, ``PUT``, ``POST``, and\n``DELETE``, in that order.\n\n```javascript\n.route(function (ANY, GET, PUT, POST, DELETE) {\n    GET(\"hello\").content(\"Hello, World!\");\n})\n```\n\nAll other valid methods are provided as functions on ``this``.\n\n```javascript\n.route(function () {\n    this.OPTIONS(\"hello\").methodNotAllowed();\n})\n```\n\nBut, you'll get proper HTTP responses for free if you use content\nnegotiation.\n\n```javascript\n.route(function ($) {\n    $(\"foo\").methods(function ($) {\n        var value;\n\n        $(\"GET\")\n        .json()\n        .app(function () {\n            return value;\n        });\n\n        $(\"PUT\")\n        .jsonRequest()\n        .tap(function (object) {\n            value = object;\n        })\n        .redirect();\n\n    })\n})\n```\n\nEach route selector accepts any number of conditions (predicates).  If\nthe predicate is a function, the function gets called with ``request``\nand ``response`` and it must return ``true`` for the route to be\nselected.\n\n```javascript\n.route(function ($) {\n    $(\"hello\", function (request) {\n        return request.headers.host === \"localhost\";\n    }).content(\"Hello\");\n})\n```\n\nSo you can profane the HTTP specification if you must:\n\n```javascript\n.route(function ($) {\n    $(function (request) {\n        return request.method === \"NYANCAT\";\n    }).redirect(\"http://nyan.cat/\");\n})\n```\n\nIf no route is selected, the route will continue searching for an app\ndown the chain.\n\n```javascript\n.route(function ($, GET) {\n    GET(\"hello\").content(\"Hello, World\")\n})\n.redirectTemporary(\"hello\")\n```\n\nYou can put a cap on routing, which will end a route.  If a request\nreaches a route cap with any part of the request URL unprocessed the\nserver will respond with a 404 \"Not Found\".\n\n```javascript\n.cap()\n```\n\n\nNegotiation\n-----------\n\nYou can use chains to limit what HTTP Method and Host you are willing to\nrespond to.\n\n```javascript\n.host(\"localhost\")\n.method(\"GET\")\n```\n\nAnd you can and should use chains to perform content-negotiation.  With\nthe ``contentType``, ``language``, ``encoding``, ``charset``  functions,\nrouting will only proceed through the chain if the client is able to\naccept the given parameter.  This is what Corbain Dallas would probably\ncall Content Negotiation.\n\n```javascript\n.charset(\"utf-8\")\n.contentType(\"text/html\")\n.language(\"en\")\n.content(\"I wonder.\")\n```\n\nOnce negotiation is complete, the corresponding response headers are\nautomatically populated.  So, if you've negotiated to respond in\n``text/html``, the ``Content-Type`` header of the response will be sent\nwith the headers automatically.  It is however up to you to ensure that\nyour response content satisfies the negotiated terms.  The negotiation\nresults are stored in ``request.terms``.\n\n```javascript\n.charset(\"utf-8\", \"ascii\")\n.app(function (request) {\n    assert.ok([\"utf-8\", \"ascii\"].indexOf(request.terms.charset) >= 0);\n})\n```\n\nAlternately, you can bring multiple options to the content negotiation.\n\n```javascript\n.route(function ($, GET) {\n    GET(\"foo\").route(function (\".\", function (ext) {\n        ext(\"html\").app(html);\n        ext(\"text\").app(text);\n        ext(\"txt\").app(text);\n    })\n    .contentTypes(function (type) {\n        type(\"text/html\").app(html);\n        type(\"text/plain\").app(text);\n    })\n})\n```\n\nYou can branch likewise on hosts:\n\n```javascript\n.host(\"localhost:*\", \"127.0.0.1:*\")\n.hosts(function ($) {\n    $(\"localhost:*\", \"127.0.0.1:*\")\n    .contentType(\"text/plain\")\n    .content(\"Hello, local client.\")\n    .cap()\n})\n```\n\n-   ``hosts``\n-   ``methods``\n-   ``contentTypes``\n-   ``languages``\n-   ``charsets``\n-   ``encodings``\n\n\nMiddleware\n----------\n\nAnd you can wrap your route in middleware.\n\nLogging middleware shows request and response times and statuses.\n\n```javascript\n.log()\n.log(console.log, stamp(message))\n```\n\nError middleware transforms errors into 500 Server Error pages.\n\n```javascript\n.error()\n```\n\nFavicon middleware handles requests for ``/favicon.ico``.\n\n```javascript\n.favicon()\n.favicon(path)\n```\n\nAnd to avoid carpal tunnel, you can just use sensible defaults for\nmiddleware.\n\n```javascript\n.blah()\n.blah({\n    log: console.log,\n    stamp: function (message) {return new Date() + \" \"},\n    favicon: path,\n    debug: true\n})\n```\n\nIn fact, if you're in a real hurry, as in say, on a REPL, you can go\nstraight into blah from the `\"joey\"` module.\n\n```javascript\nrequire(\"joey\").blah().content(\"hi\").listen(8080)\n```\n\nOr, create your own JSGI Middleware and hook it up:\n\n```javascript\n.use(function (next) {\n    return Middleware(next);\n})\n```\n\n\nAdapters\n--------\n\nAnd there are a couple adapters for formatting responses, as in JSON.\n\n```javascript\n.json()\n.app(function () {\n    return {a: 10};\n})\n```\n\nOr Node's variable inspection format.\n\n```javascript\n.inspect()\n.app(function (request) {\n    return request;\n});\n```\n\nOr create your own JSGI adapter and hook it up:\n\n```javascript\n.use(function (next) {\n    return Adapter(...options, next);\n});\n```\n\nThis adds a link to the chain, which will get connected to the\n``next`` application, or ``undefined`` when the chain terminates.\n\n```javascript\n.terminate(function () {\n    return function (request, response) {\n        // end of the chain\n        // returns its own response,\n        // does not forward to next application\n    };\n})\n```\n\nYou can instantiate a JSGI application from the chain by terminating it.\nThe return value is an app, not a link in the chain.\n\n```javascript\n.done()\n```\n\n\nLicense\n=======\n\nCopyright (c) 2012, Motorola Mobility LLC.\nAll Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n- Redistributions of source code must retain the above copyright notice,\n  this list of conditions and the following disclaimer.\n\n- Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n- Neither the name of Motorola Mobility LLC nor the names of its\n  contributors may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n\n",
  "readmeFilename": "README.md",
  "gitHead": "b80dab0662be470f6810c1b932a09e3de132de61",
  "bugs": {
    "url": "https://github.com/montagejs/joey/issues"
  },
  "homepage": "https://github.com/montagejs/joey#readme",
  "_id": "joey@1.5.3",
  "_shasum": "e5ca41b46899cf665a21079ef6b8c33a3af17744",
  "_from": "joey@latest"
}
